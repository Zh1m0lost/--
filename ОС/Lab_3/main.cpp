#include <iostream>
#include <windows.h>
#include <ctime>
#include <cstdlib>
using namespace std;

void fsort(int *arr[], int asize, HANDLE h) // Сортировка
{
    bool check = true;
    while (check)
    {
        check = false;
        for (int i = 0; i < asize - 1; i++)
            if (HeapSize(h, 0, arr[i]) > HeapSize(h, 0, arr[i + 1]))
            {
                int *tmp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = tmp;
                check = true;
            }
    }
}
void error_check(void *ptr) // Проверка на пустоту.
{
    if (ptr == NULL)
        throw 1;
}
int main()
{
    try
    {
        HANDLE head_p = NULL;
        head_p = HeapCreate( // Создает частный объект кучи, который может использоваться вызывающим процессом. Если функция завершается успешно, возвращаемое значение является дескриптором вновь созданной кучи. Если функция не работает, возвращаемое значение равно NULL.
            0,               // Параметры распределения кучи. Эти параметры влияют на последующий доступ к новой куче посредством вызовов функций кучи. Этот параметр может быть равен 0 или одному или нескольким значений.
            0x1000,          // Начальный размер кучи, в байтах. Это значение определяет начальный объем памяти, выделяемый для кучи.
            0);              // Максимальный размер кучи, в байтах. Если dwMaximumSize равен 0, то куча может увеличиваться в размере. Размер кучи ограничен только доступной памятью.
        error_check(head_p);
        srand(time(0)); // Число для генерации рандома.
        int array_size;
        cout << "Enter the size of your array >= 5: ";
        cin >> array_size;
        while (array_size < 5)
        {
            cout << "Entered value is less than 5, try again: ";
            cin >> array_size;
        }
        int **array_p = (int **)HeapAlloc( // Выделяет блок памяти из кучи. Выделенная память не является подвижной. Если функция выполняется успешно, возвращаемое значение является указателем на выделенный блок памяти. Если функция не работает и вы не указали HEAP_GENERATE_EXCEPTIONS, возвращаемое значение равно NULL.
            head_p,                        // Дескриптор кучи, из которой будет выделена память.
            0,                             // Параметры распределения кучи.
            array_size * sizeof(int *));   // Количество выделяемых байтов.
        for (int i = 0; i < array_size; i++)
        {
            array_p[i] = (int *)HeapAlloc( // Выделяем память под максимальную длину массива.
                head_p,
                0,
                10 * sizeof(int));
            error_check(array_p[i]);
            int length = rand() % 10 + 1;    // Выделяем под случайно сгенерированное количество элементов.
            array_p[i] = (int *)HeapReAlloc( // Перераспределяет блок памяти из кучи. Эта функция позволяет изменять размер блока памяти и изменять другие свойства блока памяти. Выделенная память не является подвижной. Если функция выполняется успешно, возвращаемое значение является указателем на перераспределенный блок памяти. Если функция не работает и вы не указали HEAP_GENERATE_EXCEPTIONS, возвращаемое значение равно NULL.
                head_p,                      // Дескриптор кучи, из которой должна быть перераспределена память.
                0,                           // Параметры перераспределения кучи.
                array_p[i],                  // Указатель на блок памяти, который функция перераспределяет.
                length * sizeof(int));       // Новый размер блока памяти, в байтах. Размер блока памяти может быть увеличен или уменьшен с помощью этой функции.
            error_check(array_p[i]);
            for (int j = 0; j < length; j++) // Выводим случайно сгенерированные элементы.
            {
                cout.fill(' '); // Символ для заполнения пустого пространства.
                cout.width(3);  // Минимальное количество символов, которые будет использовать следующие выходные значения.
                *(array_p[i] + j) = rand() % 10 + 1;
                cout << *(array_p[i] + j);
            }
            cout << endl;
        }
        for (int i = 0; i < array_size; i++) // Выводим длину каждой кучи.
        {
            SIZE_T n;
            n = HeapSize(    // Извлекает размер блока памяти, выделенного из кучи функцией HeapAlloc или HeapReAlloc. Если функция выполняется успешно, то возвращаемым значением является запрошенный размер выделенного блока памяти в байтах. Если функция не работает, то возвращаемое значение равно (SIZE_T)-1.
                head_p,      // Дескриптор кучи, в которой находится блок памяти.
                0,           // Параметры размера кучи.
                array_p[i]); // Указатель на блок памяти, размер которого получит функция.
            error_check(&n);
            if (n == 0)
            {
                cout << "Error of heapsize: " << GetLastError();
                return 1;
            }
            cout << "Size of line number: " << i + 1 << " = " << n / sizeof(int) << endl;
        }
        fsort(array_p, array_size, head_p);
        for (int i = 0; i < array_size; i++)
        {
            for (int j = 0; j < (int)HeapSize(head_p, 0, array_p[i]) / sizeof(int); j++)
            {
                cout.fill(' ');
                cout.width(3);
                cout << *(array_p[i] + j);
            }
            cout << endl;
        }
        if (HeapDestroy(      // Уничтожает указанный объект кучи. Handle к куче, которая будет уничтожена.
                head_p) == 0) // Handle к куче, которая будет уничтожена.
            cout << "Error of deleating heap: " << GetLastError() << endl;
    }
    catch (int)
    {
        cout << "Error number: " << GetLastError();
        return 1;
    }
}
