#include <iostream>
#include <Windows.h>
#include <conio.h>
using namespace std;
//------------------ЗАДАНИЕ 1------------------
int main()
{
  STARTUPINFOA si;        // Структура STARTUPINFO используется с функциями CreateProcess, CreateProcessAsUser, CreateProcessWithLogonW, чтобы определить оконный терминал, рабочий стол, стандартный дескриптор и внешний вид основного окна для нового процесса.
  PROCESS_INFORMATION pi; // Структура PROCESS_INFORMATION заполняется функцией CreateProcess с информацией о недавно созданном процессе и его первичном потоке.
  ZeroMemory(&si, sizeof(si));
  si.cb = sizeof(si);
  ZeroMemory(&pi, sizeof(pi));
  char command_name1[] = "dialer.exe"; // Я работаю на Windows 10 и калькулятор на этой системе не подходит для лабораторной, поэтому пришлось искать процессы, с которыми возможно её выполнить и это один из них.
  LPSTR command_line = command_name1;
  if (!CreateProcessA(  // Функция CreateProcess создает новый процесс и его первичный (главный) поток. Новый процесс запускает заданный исполняемый файл в контексте безопасности вызывающего процесса.
          NULL,         // Имя исполняемого модуля. Параметр lpApplicationName может быть значением ПУСТО (NULL). В этом случае, имя модуля должно быть в строке lpCommandLine как первое незаполненное пространство, разграниченное маркером.
          command_line, // Командная строка. Указатель на строку с символом нуля в конце, определяющую командную строку для выполнения.
          NULL,         // Указатель на структуру SECURITY_ATTRIBUTES, которая обуславливает, может ли возвращенный дескриптор быть унаследован дочерними процессами. Если lpProcessAttributes имеет значение ПУСТО (NULL), дескриптор не может быть унаследован.
          NULL,         // Указатель на структуру SECURITY_ATTRIBUTES, которая обуславливает, может ли возвращенный дескриптор быть унаследован дочерними процессами. Если lpThreadAttributes имеет значение ПУСТО (NULL), дескриптор не может быть унаследован.
          FALSE,        // Если этот параметр - ИСТИНА (TRUE), каждый наследуемый дескриптор в вызывающем процессе наследуется новым процессом. Если этот параметр - ЛОЖЬ (FALSE), дескрипторы не наследуются.
          0,            // Флажков нет. Флажки, которые управляют классом приоритета и созданием процесса.
          NULL,         // Указатель на блок конфигурации нового процесса. Если этот параметр имеет значение ПУСТО (NULL), новый процесс использует конфигурацию вызывающего процесса.
          NULL,         // Указатель на строку с символом нуля в конце, определяющую текущий диск и каталог для дочернего процесса. Если этот параметр является значением ПУСТО (NULL), новый процесс создается с тем же самым текущим диском и каталогом, что и вызывающий процесс.
          &si,          // Указатель на структуру STARTUPINFO, которая устанавливает оконный режим терминала, рабочий стол, стандартные дескрипторы и внешний вид главного окна для нового процесса.
          &pi           // Указатель на структуру PROCESS_INFORMATION, которая принимает идентифицирующую информацию о новом процессе.
          ))
  {
    cout << "Process creating error: " << GetLastError() << endl;
    return 0;
  }
  else
  {
    cout << "Process ID: " << pi.dwProcessId << endl; // dwProcessId - Значение, которое может быть использовано для идентификации процесса. Значение правильно с момента создания процесса до момента, пока процесс не завершит работу.
  }

  bool exit_code = false;
  while (GetAsyncKeyState(0x30) != -32767) // Число которое возвращает функция если нажата нужная клавиша.
  {
    cout << "s - Suspend \n"
         << "r - Resume \n"
         << "t - Terminate \n"
         << "q - Exit \n"
         << "------------ \n";
    int key = _getch(); // Функция getch нужна для чтения одного символа с клавиатуры, этот символ на экран не выводится.
    switch (key)
    {
    case 115:
      if (SuspendThread( // Функция SuspendThread приостанавливает работу заданного потока. Если функция завершается успешно, величина возвращаемого значения - счет времени предыдущей приостановки работы потока; иначе, оно равно - (минус) 1.
              pi.hThread) == -1)
        cout << "Suspending thread error: " << GetLastError() << endl;
      break;
    case 114:
      if (ResumeThread( // Функция ResumeThread уменьшает счет времени приостановки работы потока. Когда счет времени приостановки работы уменьшается до нуля, выполнение потока продолжается. Если функция завершается успешно, величина возвращаемого значения - предшествующий счет времени приостановки работы потока. Если функция завершается с ошибкой, величина возвращаемого значения равна - (минус) 1.
              pi.hThread) == -1)
        cout << "Resuming thread error: " << GetLastError() << endl;
      break;
    case 116:
      if (!TerminateProcess( // Функция TerminateProcess завершает работу заданного процесса и всех его потоков. Если функция завершается успешно, величина возвращаемого значения - не ноль. Если функция завершается с ошибкой, величина возвращаемого значения - ноль.
              pi.hProcess,
              0)) // Код выхода из процесса.
        cout << "Terminating process error:  " << GetLastError() << endl;
      else
        exit_code = true;
      cout << "Process terminated successfully" << endl;
      break;
    case 113:
      exit_code = true;
      break;
    default:
      cout << "Invalid character" << endl;
      break;
    }
    if (exit_code)
      break;
  }
  CloseHandle(pi.hProcess);
  CloseHandle(pi.hThread);
  //------------------ЗАДАНИЕ 2------------------
  char command_name2[] = "notepad.exe";
  command_line = command_name2;
  if (!CreateProcessA(
          NULL,
          command_line,
          NULL,
          NULL,
          FALSE, // Поток создается в приостановленном состоянии и не запускается до тех пор, пока не будет вызвана функция ResumeThread.
          CREATE_SUSPENDED,
          NULL,
          NULL,
          &si,
          &pi)

  )
  {
    cout << "Process creating error: " << GetLastError() << endl;
    return 0;
  }
  else
  {
    cout << "Process ID: " << pi.dwProcessId << endl;
  }
  Sleep(10000);     // По истечении 10 секунд поток созданного процесса должен возобновить выполнение.
  if (ResumeThread( // Функция ResumeThread уменьшает счет времени приостановки работы потока. Когда счет времени приостановки работы уменьшается до нуля, выполнение потока продолжается. Если функция завершается успешно, величина возвращаемого значения - предшествующий счет времени приостановки работы потока. Если функция завершается с ошибкой, величина возвращаемого значения равна - (минус) 1.
          pi.hThread) == -1)
    cout << "Resuming thread error: " << GetLastError() << endl;
  cout << "Priority: " << GetThreadPriority(pi.hThread) << endl; // Функция GetThreadPriority извлекает значение приоритета для определяемого потока. Это значение, вместе с классом приоритета процесса потока, обуславливает уровень базового приоритета потока. Если функция завершается успешно, величина возвращаемого значения - уровень приоритета потока.
                                                                 // Значение = 0: THREAD_PRIORITY_NORMAL - Обозначает нормальный приоритет для класса приоритета.
                                                                 // THREAD_PRIORITY_ABOVE_NORMAL - Приоритет на 1 пункт выше класса приоритета.
                                                                 // THREAD_PRIORITY_BELOW_NORMAL - Приоритет на 1 пункт ниже класса приоритета.
                                                                 // THREAD_PRIORITY_HIGHEST - Приоритет на 2 пункта выше класса приоритета.
                                                                 // THREAD_PRIORITY_LOWEST - Приоритет на 2 пункта ниже класса приоритета.
                                                                 // THREAD_PRIORITY_IDLE - Базовый приоритет 1 для IDLE_PRIORITY_CLASS, BELOW_NORMAL_PRIORITY_CLASS, NORMAL_PRIORITY_CLASS, ABOVE_NORMAL_PRIORITY_CLASS или HIGH_PRIORITY_CLASS процессов и базовый приоритет 16 для процессов REALTIME_PRIORITY_CLASS.
                                                                 // THREAD_PRIORITY_TIME_CRITICAL - Уровень базового приоритета 15 для процессов IDLE_PRIORITY_CLASS, BELOW_NORMAL_PRIORITY_CLASS, NORMAL_PRIORITY_CLASS, ABOVE_NORMAL_PRIORITY_CLASS или HIGH_PRIORITY_CLASS, и уровень базового приоритета 31 для процессов REALTIME_PRIORITY_CLASS.
// Каждая программа, запущенная в Windows, представляет из себя процесс или несколько процессов.
// Под каждый процесс, при его запуске, в системе выделяется память, а так же устанавливается приоритет по умолчанию, если только в самой программе нет упоминания о приоритете, с которым необходимо её запускать.
// Чем выше приоритет процесса, тем больше ему выделяется процессорного времени, чем ниже приоритет, тем меньше процессу выделяется процессорного времени.
// Или если простым языком - чем выше приоритет, тем чаще и больше процессор «уделяет внимание» процессу и его операциям, а чем ниже приоритет, тем меньше «уделяет внимание».
// Соответственно это сказывается на скорости выполнение той или иной программы.

  CloseHandle(pi.hProcess);
  CloseHandle(pi.hThread);
  return 0;
}
